---
title: "Resiliência"
description: "Como o BackBet se protege contra falhas em dependências, picos de tráfego e erros inesperados."
slug: "/docs/resilience"
---

# Resiliência operando em camadas

:::note Visão geral
O BackBet é projetado para sobreviver a falhas externas (Clerk, Redis, Mongo), picos de autenticação e indisponibilidade parcial. A seguir detalhamos como API, cache, persistência e observabilidade se combinam para evitar downtime e acelerar a recuperação.
:::

## 1. API e experiência do cliente

| Proteção | Resultado | Onde configurar |
|----------|-----------|-----------------|
| Rate limiting global/por rota | Contém spikes em `POST /auth/login`, `/wallets/deposit`, `/bets` e propaga `RateLimit-*` headers para o cliente | `rateLimit` e `createRouteRateLimiter` em `src/shared/config/appConfig.ts` |
| Fallback de autenticação | Permite JWT local ou `Bearer <userId>` em dev quando Clerk está indisponível | `ALLOW_DEV_BEARER_BYPASS=true` |
| Timeouts + abort signals | Respostas rápidas mesmo quando serviços externos degradam; adicione notas no README ao incluir novos SDKs | Middlewares + `walletService`/`betService` |
| Retries / circuit breakers | Isola Redis/Mongo quando instáveis antes que afetem usuários | `src/shared/resilience/*`, `src/infrastructure/observability/resilienceMetrics.ts` |

### Operação diária

- Monitore `request_start`, `request_end` e `request_error` para validar tempo de resposta por rota.
- Documente qualquer alteração em limites ou SDKs no README para manter o histórico operacional.

## 2. Cache e desacoplamento

| Componente | Como ajuda | Ações recomendadas |
|------------|------------|--------------------|
| Redis em `/users/me`, `/wallets/me`, `/bets` | Serve respostas rápidas; se cair, o código faz fallback para leitura direta | `cacheConfig.enabled` + flag `CACHE_ENABLED` para desligar em emergência |
| `cacheHooks` + `cacheMetricsSnapshot` | Expõe hits, misses, writes e errors para detectar desvios antes de afetar o Mongo | Consulte o painel ou `/health/cache` para ajustes proativos |
| Readiness handler | Replica o estado do cache e devolve `status: down` quando o ping falha | Use alertas baseados no retorno de `/health/cache` |

:::tip Load balancer
Provedores como Nginx/ALB podem usar `/health/cache` e `/readiness` para retirar instâncias problemáticas do pool antes que clientes percebam.
:::

## 3. Persistência e banco de dados

1. **Fábrica de repositórios** (`src/infrastructure/persistence/factory.ts`): alterna para implementações in-memory quando o Mongo oscila.
2. **Configuração obrigatória**: `USE_MONGOOSE_PERSISTENCE=true` em produção + `connectMongoDB()` com `retryWrites: true` (ver `config.ts`).
3. **Readiness defensivo**: `ApiServer.readinessHandler` grava o resultado de cada ping em `dependencyHealthSnapshot`; falhas retornam `503` e `ready=false`, evitando tráfego enquanto o cluster se recupera.
4. **Migrações e índices**: mantenha `schemas` sincronizados (guia em `docs/MONGOOSE_REPOSITORIES.mdx`) para evitar erros de constraint duplicada.

## 4. Observabilidade e alertas

- Logs estruturados incluem `requestId`, `userId` e `durationMs` (documentado em `docs/LOGS.mdx`).
- Spans OTEL permanecem disponíveis e, junto com `dependencyHealthSnapshot`, indicam degradações. Os painéis antigos (Grafana/Prometheus) foram arquivados; seguimos `docs/PM2-WEBUI-MIGRATION.mdx`.
- **PM2** mantém reloads sem downtime via `pm2 start ecosystem.config.cjs` (detalhes em `docs/PM2.mdx`).
- Health checks públicos (`/health`, `/health/cache`, `/readiness`) podem alimentar Uptime Robots; proteja por reverse proxy em produção conforme `docs/OBSERVABILITY.mdx`.
- `/metrics` responde `410 Gone` enquanto `OBS_ENABLE_PROMETHEUS=false`; o monitoramento migra para PM2 WebUI + alertas por e-mail.
- `resilienceMetricsSnapshot` agrega retries, aberturas de circuit breaker e falhas; será enviado ao PM2 WebUI/alertas na próxima fase.

## 5. Estratégias de tolerância a falhas futuras

1. **Retries inteligentes**: adicione libs como `p-retry` aos adaptadores de Clerk/Redis para backoff exponencial.
2. **Circuit breaker dedicado**: um por integração crítica (Clerk, Redis, Mongo) com limites ajustados a cada SLA.
3. **Resposta degradê**: quando Clerk falhar, devolva mensagem orientando o usuário (ex.: `418` com instruções) enquanto o monitor dispara alertas automáticos.
4. **Chaos testing**: roteiros que derrubam Redis/Mongo em staging e verificam `/readiness` + `/health/cache` garantem confiança nas rotas de fallback.

## 6. Checklist de resiliência

- [ ] Validar rate limits em testes de carga e garantir `RateLimit-*` nos logs `request_end`.
- [ ] Documentar `USE_MONGOOSE_PERSISTENCE` e `MONGODB_URI` por ambiente (DEV/HML/PROD).
- [ ] Monitorar `dependencyHealthSnapshot` (via `/readiness`) e acionar alertas ao detectar `status="down"`.
- [ ] Simular falhas de Redis/Mongo e garantir que `request_error`/`readiness_dependency` expliquem a causa raiz.

**Referências rápidas:** `docs/OBSERVABILITY.mdx`, `docs/LOGS.mdx`, `docs/MONGODB_SETUP.mdx`, `src/infrastructure/api/ApiServer.ts`, `src/shared/config/appConfig.ts`.
