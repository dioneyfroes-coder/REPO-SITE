---
title: "Integração Clerk"
description: "Configuração da autenticação Clerk no BackBet (produção e desenvolvimento)."
slug: "/clerk-setup"
---

# Integração Clerk

O BackBet usa o **Clerk** como provedor primário de autenticação em produção. Em desenvolvimento/teste é possível usar o bypass de bearer (`ALLOW_DEV_BEARER_BYPASS`) ou JWT local (`JwtService`). Este guia mostra como habilitar cada modo e quais rotas/middlewares dependem do Clerk.

## 1. Modos de Autenticação

| Ambiente | Configuração | Comportamento |
|----------|--------------|---------------|
| **Produção** | Defina `CLERK_SECRET_KEY` real (sem `sk_test`) e `ALLOW_DEV_BEARER_BYPASS=false`. | `clerkMiddleware` autentica todas as rotas, `ClerkService` sincroniza perfis e impede bypass. |
| **Staging** | Use chaves reais ou de staging e mantenha `ALLOW_DEV_BEARER_BYPASS=false`. | Mesmo fluxo da produção, ideal para validação final. |
| **Desenvolvimento/Teste** | Use `CLERK_SECRET_KEY=sk_test...` ou deixe em branco e configure `ALLOW_DEV_BEARER_BYPASS=true`. | O middleware aceita `Authorization: Bearer <userId>` (qualquer string) e cria sessões mockadas. JWT local continua disponível. |

> Se `appConfig.env === 'production'` e não houver `CLERK_SECRET_KEY` válido, o servidor aborta o boot para evitar rodar sem autenticação.

## 2. Criando uma aplicação no Clerk

1. Acesse [dashboard.clerk.com](https://dashboard.clerk.com) e crie uma aplicação (ex.: `backbet-api`).
2. Em **API Keys**, copie:
   - `CLERK_PUBLISHABLE_KEY`
   - `CLERK_SECRET_KEY`
   - (Opcional) `CLERK_API_KEY` para chamadas administrativas.
3. Em **Allowlist** defina as origens do frontend (`https://app.backbet.com`, `http://localhost:5173`, etc.).

## 3. Variáveis de ambiente

Atualize `.env` (não versione):

```env
# Clerk
CLERK_PUBLISHABLE_KEY=pk_live_xxxxx
CLERK_SECRET_KEY=sk_live_xxxxx
CLERK_API_KEY=sk_live_xxxxx   # Opcional para sync avançado
CLERK_SIGN_IN_URL=https://backbet.Clerk.accounts.dev/sign-in   # usado pelo frontend

# Bypass (somente dev/test)
ALLOW_DEV_BEARER_BYPASS=false   # true permite Authorization: Bearer <userId>
```

Outros toggles relevantes:
- `JWT_SECRET` (para `/api/auth/login`/`refresh`).
- `appConfig.security.enableHsts` e `appConfig.cors.allowedOrigins` para alinhar com as origens liberadas no Clerk.

## 4. Como o backend usa o Clerk

### Middleware de autenticação

`ApiServer` aplica automaticamente:

```ts
if (allowDevBypass) {
  // usa Authorization: Bearer <userId>
} else {
  this.app.use(clerkMiddleware());
}
```

- `allowDevBypass` é `true` apenas quando **não** há chave secreta válida ou quando `ALLOW_DEV_BEARER_BYPASS=true` fora de produção.
- O middleware popula `req.auth.userId` e `req.auth.sessionId`, usados por `protectedRoute` e `requestContext`.

### ClerkService

`src/shared/services/ClerkService.ts` encapsula `@clerk/clerk-sdk-node`.

- Métodos principais: `getUserById`, `syncUser`, `sanitizeProfile`.
- `createAuthRoutes` injeta o `ClerkService` para enriquecer `/api/auth/me` e sincronizar registro (`POST /auth/register`).
- Se `CLERK_SECRET_KEY` for inválido ou estiver ausente, o serviço opera no modo no-op e os endpoints continuam funcionais usando apenas o domínio.

### Proteções nas rotas

- `protectedRoute` verifica `req.auth?.userId` antes de chamar controllers (`users`, `wallets`, `bets`, `finance`).
- `requireRoles(['ADMIN'])` (quando presente) compara o papel retornado pelo Clerk com o esperado.

## 5. Fluxos

### Login/registro

1. Frontend usa Clerk (React/Next SDK) para autenticar o usuário.
2. Clerk retorna `Session`/`token`. O frontend chama o BackBet com `Authorization: Bearer <token>`.
3. `clerkMiddleware` valida o token, popula `req.auth`. Em modo dev com bypass, basta enviar `Authorization: Bearer user_123`.
4. Controllers usam `req.auth.userId` para localizar o usuário BackBet (sincronizado na primeira chamada via `ClerkService`).

### Rotas protegidas

```
Client → Authorization: Bearer <Clerk JWT ou userId dev>
  ↓
ApiServer.clerkMiddleware / bypass
  ↓ req.auth.userId definido
protectedRoute & guards
  ↓
Controller + Use case + cache hooks
```

### Logout

- No Clerk é client-side (`Clerk.signOut()`), mas expomos `POST /api/auth/logout` como “ack” para manter consistência com clientes sem Clerk.

## 6. Integração Frontend (Next.js exemplo)

```tsx
import { ClerkProvider } from '@clerk/nextjs';
import { dark } from '@clerk/themes';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider
      publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}
      afterSignInUrl="/dashboard"
      appearance={{ baseTheme: dark }}
    >
      {children}
    </ClerkProvider>
  );
}
```

Para requisições autenticadas:

```ts
import { auth } from '@clerk/nextjs';

export async function fetchApi(input: RequestInfo, init?: RequestInit) {
  const { getToken } = auth();
  const token = await getToken();
  return fetch(`${process.env.NEXT_PUBLIC_API_URL}${input}`, {
    ...init,
    headers: {
      ...(init?.headers || {}),
      Authorization: `Bearer ${token}`,
    },
  });
}
```

Em ambientes sem Clerk, o frontend pode pegar o `userId` fake (ex.: `user_dev_001`) e enviar direto como bearer.

## 7. Segurança

- Exigir HTTPS nas origens cadastradas no Clerk (o serviço rejeita chamadas HTTP em produção).
- Nunca logar tokens. O `loggingMiddleware` registra apenas `requestId`, `userId` e metadados.
- `requestContext` propaga `userId` para auditar cada operação.
- Rate limits específicos (`AUTH_*_RATE_LIMIT_*`) previnem brute force mesmo quando o Clerk está indisponível.

## 8. Troubleshooting

| Problema | Passos |
|----------|--------|
| `CLERK_SECRET_KEY must be configured in production` | Aplique uma chave real (`sk_live...`) ou desça o ambiente (`NODE_ENV=development`). |
| `Invalid API key` / 401 | Verifique se a chave pertence à mesma aplicação no dashboard e se não possui espaços extras. |
| `Unauthorized` em dev | Confirme se `ALLOW_DEV_BEARER_BYPASS=true` e envie `Authorization: Bearer <qualquerUserId>` sem dots (não pode parecer JWT). |
| `CORS` no Clerk Hosted Pages | Inclua o domínio do frontend nas allowlists do Clerk **e** em `appConfig.cors.allowedOrigins`. |
| Perfis divergentes | Rode `ClerkService.syncUser({ email, userId })` (feito automaticamente ao registrar) ou ajuste manualmente via dashboard. |

## 9. Próximos passos

1. Concluir testes end-to-end cobrindo Clerk + cache.
2. Criar webhook de eventos do Clerk (user.created/user.updated) para sincronizar status automaticamente.
3. Evoluir o JWT local para fallback completo (refresh tokens) quando o Clerk estiver indisponível.

---

**Última atualização:** 23 de novembro de 2025
