---
title: "Módulo Finanças"
description: "Como o núcleo financeiro emite carteiras, pacotes de crédito e saques com cache, rate limit e integrações com Betting."
slug: "/docs/finance"
---

# Core Finance

> Camada responsável por créditos dos usuários (balance + lockedBalance), pacotes promocionais e solicitações de saque. Tudo é construído sobre DDD, value objects e use cases reutilizáveis por Auth, Betting e painéis administrativos.

## Estrutura

```
src/core/finance/
  domain/
    entities/{Wallet,Transaction,CreditPackage,WithdrawalRequest}.ts
    value-objects/Currency.ts
    services/{WalletService,CreditPackageService,WithdrawalRequestService,IWalletService}.ts
    repositories/{IWalletRepository,WalletRepository,ICreditPackageRepository,...}.ts
  application/
    errors/WalletErrorMapper.ts
    use-cases/
      {GetWallet,Deposit,Withdraw,GetHistory,
       ListCreditPackages,PurchaseCreditPackage,
       RequestWithdrawal,GetWithdrawalRequests,
       ProcessWithdrawalRequest}.ts
  types/wallet.types.ts
src/infrastructure/
  api/controllers/{WalletController,FinanceController}.ts
  api/routes/{walletRoutes,financeRoutes}.ts
  api/dtos/{WalletDTOs,FinanceDTOs}.ts
  api/middleware/{cacheMiddleware,routeRateLimiter}.ts
  cache/{RedisClient,cacheHooks,cacheKeys}.ts
  persistence/factory.ts (seleciona repos in-memory ou Mongoose via USE_MONGOOSE_PERSISTENCE)
src/scripts/seedCreditPackages.ts (popular pacotes padrão)
```

## Domínio e entidades

### Wallet (`src/core/finance/domain/entities/Wallet.ts`)
- Mantém `balance`, `lockedBalance`, `currency` e histórico de `Transaction`.
- Expõe operações atômicas: `deposit`, `withdraw`, `lock`, `unlock`, `withdrawLocked`, todas validadas por `Money` (value object compartilhado) e lançando `DomainError` (`WALLET_INVALID_AMOUNT`, `WALLET_INSUFFICIENT_FUNDS`, etc.).
- `recordTransaction` gera `Transaction` com `type` (`deposit`, `withdraw`, `lock`, `unlock`, `withdraw_locked`) e agrega telemetria local sem bloquear o fluxo caso a criação falhe.

### Transaction (`src/core/finance/domain/entities/Transaction.ts`)
- DTO-friendly (`toDTO`) usado pelo histórico paginado (`IWalletRepository.getHistory`).
- Não há persistência própria; cabe ao repositório escolher salvar em Mongo/Mongoose ou manter em memória.

### CreditPackage (`src/core/finance/domain/entities/CreditPackage.ts`)
- Define pacotes com `baseAmount`, `bonusAmount`, `totalCredits`, `price` e `isActive`.
- Usado para `PurchaseCreditPackage`, retornando `creditPackage.toDTO()` para front e painel.

### WithdrawalRequest (`src/core/finance/domain/entities/WithdrawalRequest.ts`)
- Representa todo saque manual, com `status` (`PENDING`, `APPROVED`, `REJECTED`), `ApprovalLog` e validação de valor.
- `approve`/`reject` adicionam logs e garantem que cada solicitação só seja processada uma vez.

### CurrencyValueObject (`src/core/finance/domain/value-objects/Currency.ts`)
- Aceita apenas `BRL | USD | EUR`. Valores inválidos disparam `DomainError('CURRENCY_INVALID_CODE')` e são convertidos para `AppError` via mapper.

## Serviços e repositórios

- `WalletService`: orquestra verificações e delega persistência para `IWalletRepository`. Expõe `createWallet`, `deposit`, `withdraw`, `lock`, `unlock`, `withdrawLocked`, `getHistory`.
- `IWalletService`: contrato consumido por `BetService` para debitar/creditar apostas sem acoplar a implementação concreta.
- `CreditPackageService`: lista/recupera pacotes (via `ICreditPackageRepository`) e valida existência antes da compra.
- `WithdrawalRequestService`: sincroniza `WithdrawalRequest` com operações de carteira (lock durante a criação, `withdrawLocked` ou `unlock` ao aprovar/rejeitar) e possui validações anti saldo negativo.
- `WalletRepository`, `CreditPackageRepository`, `WithdrawalRequestRepository`: implementações in-memory para dev/teste.
- `src/infrastructure/persistence/factory.ts`: carrega versões Mongoose (`MongooseWalletRepository`, etc.) quando `USE_MONGOOSE_PERSISTENCE=true`, mantendo a mesma interface para rotas Auth/Wallet/Finance.

## Casos de uso principais

| Use case | Responsabilidade | Entrada | Saída |
|----------|------------------|---------|-------|
| `GetWallet` | Busca carteira do usuário e propaga `null` se inexistente | `userId` | `Wallet | null` |
| `Deposit` / `Withdraw` | Deposita ou saca valores diretos | `userId`, `amount` | `Wallet` atualizado |
| `GetHistory` | Retorna histórico paginado (`limit`, `offset`) | `userId`, `limit`, `offset` | `{ transactions, total }` |
| `ListCreditPackages` | Lista pacotes ativos | — | `CreditPackage[]` |
| `PurchaseCreditPackage` | Deposita `base + bônus` após validar pacote | `userId`, `packageId` | `{ creditPackage, wallet }` |
| `RequestWithdrawal` / `GetWithdrawalRequests` | Cria e lista `WithdrawalRequest` bloqueando saldo | `userId`, `amount`, `currency`, `notes?` | Entidade(s) de saque |
| `ProcessWithdrawalRequest` | Aprova/rejeita e executa `withdrawLocked`/`unlock` | `requestId`, `adminId`, `action`, `notes?` | `WithdrawalRequest` atualizado |

Todos envolvem `executeWithWalletErrorMapping`, traduzindo `DomainError` em `AppError` com status HTTP coerentes.

## Fluxos ponta a ponta

### Criação de carteira no onboarding
1. `RegisterUser.execute` cria usuário e invoca `WalletService.createWallet` com moeda default (`BRL`).
2. Em caso de erro (`WALLET_ALREADY_EXISTS`), o mapper devolve 409 e o fluxo de cadastro é interrompido.

### Compra de pacote de créditos
1. `POST /api/finance/packages/:packageId/purchase` valida params (`CreditPackagePurchaseDTO`).
2. `PurchaseCreditPackage` busca o pacote, soma `base + bonus` e chama `WalletService.deposit`.
3. `flushWalletCache(userId)` limpa `wallet:balance` e `wallet:history` para refletir o novo saldo imediatamente.

### Solicitação e aprovação de saque
1. `POST /api/finance/withdrawal-requests` valida `CreateWithdrawalRequestDTO`, chama `RequestWithdrawal` que bloqueia o valor (`wallet.lock`).
2. Admins usam `PATCH /api/finance/withdrawal-requests/:id` para aprovar (`withdrawLocked`) ou rejeitar (`unlock`).
3. Cada decisão gera `ApprovalLog` e dispara `flushWalletCache`.

### Integração com Betting
- `BetService.placeBet` usa `IWalletService.withdraw` para reservar stake; cancelamentos devolvem via `deposit` e vitórias pagam `wallet.deposit(potentialReturn)`.
- Como `BetService` fala com o contrato e não com o repositório, é fácil trocar a implementação (e.g., Mongoose) sem tocar no domínio de apostas.

## HTTP API

### Rotas de carteira (`src/infrastructure/api/routes/walletRoutes.ts`)

| Método | Caminho | Proteção | Cache/Rate limit | Observações |
|--------|---------|----------|------------------|-------------|
| `GET` | `/api/wallets/me` | `protectedRoute` | `cacheWalletBalanceMiddleware` (Redis) | Retorna `wallet.toDTO()`; 404 se carteira não existir.
| `POST` | `/api/wallets/deposit` | `protectedRoute` | `createRouteRateLimiter` usando `WALLET_DEPOSIT_RATE_LIMIT_*` | Payload `DepositDTO`; dispara `flushWalletCache`.
| `POST` | `/api/wallets/withdraw` | `protectedRoute` | Rate limit `WALLET_WITHDRAW_RATE_LIMIT_*` | Usa `WithdrawDTO`; aplica validações de saldo.
| `GET` | `/api/wallets/history` | `protectedRoute` | `cacheWalletHistoryMiddleware` (cache por `limit/offset`) | Responde `{ transactions, pagination }`.

### Rotas financeiras (`src/infrastructure/api/routes/financeRoutes.ts`)

| Método | Caminho | Proteção | Observações |
|--------|---------|----------|-------------|
| `GET` | `/api/finance/packages` | `protectedRoute` | Lista pacotes ativos com datas em ISO 8601.
| `POST` | `/api/finance/packages/:packageId/purchase` | `protectedRoute` | Realiza depósito `base+bonus`, retorna carteira atualizada e pacote.
| `POST` | `/api/finance/withdrawal-requests` | `protectedRoute` | Cria solicitação de saque e bloqueia saldo.
| `GET` | `/api/finance/withdrawal-requests` | `protectedRoute` | Lista solicitações do usuário autenticado.
| `PATCH` | `/api/finance/withdrawal-requests/:requestId` | `protectedRoute` | Processa aprovação/rejeição. (Para uso administrativo; autenticação delegada a `AuthMiddleware`.)

## DTOs e validação

- `DepositDTO` / `WithdrawDTO` (`src/infrastructure/api/dtos/WalletDTOs.ts`): exigem `amount > 0`, `currency ∈ {BRL,USD,EUR}` e `description?`.
- `FinanceDTOs.ts` contém: `CreditPackagePurchaseDTO`, `CreateWithdrawalRequestDTO` (mínimo 0.01), `ProcessWithdrawalRequestDTO`, `CreditPackageResponseDTO`, `WithdrawalRequestResponseDTO`.
- Todos os controllers usam `BaseController.validateSchema` para retornar `AppError` padronizado (`code`, `message`, `status`).

## Cache e consistência

- `redisClient` lê `cacheConfig` (`REDIS_URL`, TTLs) e expõe helpers `cacheWalletBalance`, `cacheWalletHistory` e `flushWalletCache`.
- `cacheMiddleware` intercepta respostas, salva JSON e devolve hits rapidamente (inclusive com query params em `/history`).
- Sempre que a carteira muda (`deposit`, `withdraw`, compras de pacote, criação/processamento de saque) os controllers chamam `flushWalletCache` para invalidar `wallet:balance` e `wallet:history` do usuário.

## Configurações e rate limits

- **Persistência:** `USE_MONGOOSE_PERSISTENCE=true` liga repositórios Mongo (`MongooseWalletRepository`, etc.).
- **Cache:** `CACHE_ENABLED`, `CACHE_TTL_SECONDS`, `CACHE_USER_BALANCE_TTL_SECONDS`, `CACHE_WALLET_HISTORY_TTL_SECONDS`, `REDIS_URL` controlam Redis.
- **Wallet rate limit:** `WALLET_DEPOSIT_RATE_LIMIT_{WINDOW_MS,MAX,MESSAGE}` e `WALLET_WITHDRAW_RATE_LIMIT_{WINDOW_MS,MAX,MESSAGE}` abastecem `createRouteRateLimiter`.
- **Finance:** `AUTH_*` e `RATE_LIMIT_*` globais ainda protegem rotas pois herdam o middleware padrão definido em `app.ts`.

## Seeds e dados iniciais

- Rode `npm run seed:credit-packages` para criar pacotes Bronze/Prata/Ouro/VIP (`src/scripts/seedCreditPackages.ts`).
- O script reutiliza `createCreditPackageRepository`, portanto persiste tanto em memória quanto em Mongo (se `USE_MONGOOSE_PERSISTENCE=true`).
- Use esse seed sempre que subir um novo ambiente para garantir catálogos consistentes e evitar compras com pacote inexistente.

## Observabilidade e troubleshooting

- `executeWithWalletErrorMapping` converte `DomainError` → `AppError` com status (ex.: `WALLET_ALREADY_EXISTS` → 409, `WALLET_NOT_FOUND` → 404, `WALLET_INVALID_AMOUNT` → 400).
- Logs relevantes:
  - `FinanceController` loga falhas ao limpar cache.
  - `RedisClient` incrementa métricas (`hits`, `misses`, `writes`, `errors`) e emite `console.warn` quando operações falham.
- Problemas comuns:
  - `NOT_FOUND Wallet not found` → certifique-se de que o fluxo de cadastro criou a carteira (recrie com `WalletService.createWallet`).
  - `BAD_REQUEST Saldo insuficiente` em saques/withdraw → verifique `lockedBalance` e histórico.
  - `CACHE_DISABLED` (implícito) → quando `CACHE_ENABLED=false`, as rotas continuam funcionando sem Redis.

## Testes

- Suite de use cases (`src/core/finance/application/use-cases/__tests__`): `GetWallet.test.ts`, `GetHistory.test.ts`, `PurchaseCreditPackage.test.ts` garantem orquestração e integração com `WalletService`.
- Execute `npm test -- finance` (ou `npm test -- PurchaseCreditPackage`) para focar nas specs.
- Teste manualmente:
  ```bash
  curl -X POST http://localhost:3000/api/wallets/deposit     -H 'Authorization: Bearer <token>'     -H 'Content-Type: application/json'     -d '{"amount":100,"currency":"BRL"}'
  ```
- Habilite Redis antes de rodar testes end-to-end para observar `cacheWalletHistory` funcionando (`docker run -p 6379:6379 redis`).

## Próximos passos

1. Persistir histórico de `Transaction` em coleção dedicada para auditar débitos/créditos independentemente de Wallet.
2. Expor webhooks/integrações com gateways de pagamento para automatizar depósitos e conciliar purchase orders.
3. Adicionar alertas de risco (limite diário de saque, múltiplas tentativas rejeitadas) usando eventos de domínio.
4. Criar testes de integração Auth + Wallet + Finance com Redis habilitado e rate limit real para evitar regressões de cache.

---

**Última atualização:** 23 de novembro de 2025
