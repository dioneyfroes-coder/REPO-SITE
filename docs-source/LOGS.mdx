---
title: "Logs Estruturados"
description: "Guia completo de coleta, correlação e boas práticas de logging no BackBet."
slug: "/docs/logs"
---

# Logs estruturados — BackBet

> Esta página substitui o antigo changelog. Ela documenta como os logs são gerados, quais campos compõem cada entrada e como coletá-los em desenvolvimento, homologação e produção.

## Objetivos

- Garantir rastreabilidade ponta a ponta (request → log → métrica → trace).
- Fornecer um formato único de log para análise em Loki, ELK ou CloudWatch.
- Acelerar troubleshooting com campos obrigatórios (`requestId`, `userId`, `event`, `durationMs`).

## Arquitetura e arquivos relevantes

| Responsabilidade | Arquivo |
| --- | --- |
| Geração/propagação de `requestId` + `AsyncLocalStorage` | `src/shared/observability/requestContext.ts` |
| Middlewares `requestIdMiddleware` e `loggingMiddleware` | `src/infrastructure/api/ApiServer.ts` |
| Serialização de erros e logs `request_error` | `src/infrastructure/api/ApiServer.ts#registerErrorHandler` |
| Configuração dos endpoints `/health`, `/metrics`, `/readiness` (para correlação) | `src/infrastructure/api/ApiServer.ts` |
| Documentação geral de observabilidade | `docs/OBSERVABILITY.mdx` |

## Eventos emitidos automaticamente

| Evento | Nível | Quando acontece | Campos adicionais |
| --- | --- | --- | --- |
| `request_start` | `info` | Entrada no `loggingMiddleware` | `method`, `path`, `ip`, `userId` |
| `request_end` | `info` | `res.finish` | `status`, `durationMs`, `contentLength` |
| `request_error` | `error` | Middleware global captura `AppError` ou `Error` | `code`, `statusCode`, `details` |
| `request_healthcheck` | `info` | Handlers de `/health*` | `endpoint`, `result`, `cacheEnabled` |
| `readiness_dependency` | `warn`/`error` | Dependência caiu durante `/readiness` | `dependency`, `status`, `latencyMs`, `error` |
| `startup` | `info` | `ApiServer.start()` | `port`, `swaggerUrl`, `env` |

> Todos os eventos compartilham `timestamp` ISO, `requestId` (quando disponível) e `service: 'backbet-api'`.

## Formato padronizado

Cada log é uma linha JSON, enviada para `stdout`/`stderr`.

```json
{
  "level": "info",
  "event": "request_end",
  "timestamp": "2025-11-23T13:37:10.123Z",
  "requestId": "req-1732369030123-abc123",
  "method": "POST",
  "path": "/api/auth/register",
  "status": 201,
  "durationMs": 128.42,
  "userId": "user_2YQk",
  "ip": "2804:14c:..."
}
```

Campos obrigatórios: `level`, `event`, `timestamp`. Prefira snake-case apenas para campos herdados de payloads externos; demais campos usam camelCase.

## Contexto e correlação

- `requestId` vem do cabeçalho `X-Request-ID` ou é criado em `requestIdMiddleware` e propagado via `runWithRequestContext`.
- `updateRequestContext` injeta `userId` assim que o middleware de autenticação resolve o usuário; o valor fica disponível em qualquer camada (use cases, repositórios) via `getRequestContext()`.
- `traceId` aparece nos headers OTLP quando `TRACING_ENABLED=true`. Inclua `traceId` manualmente em logs específicos caso esteja instrumentando novas dependências externas.

### Logs customizados em casos de uso

```ts
import { getRequestContext } from '@/shared/observability/requestContext';

const ctx = getRequestContext();
console.log(
  JSON.stringify({
    level: 'info',
    event: 'wallet_deposit_completed',
    requestId: ctx?.requestId,
    userId: ctx?.userId,
    amount: payload.amount,
  }),
);
```

Sempre serializamos manualmente para JSON para evitar diferenças entre runtimes e facilitar a ingestão no Loki.

## Severidade e política de níveis

| Nível | Uso permitido | Ações recomendadas |
| --- | --- | --- |
| `info` | Eventos esperados (start/end, mutações bem-sucedidas) | Mantido em todos os ambientes; base para métricas derivadas |
| `warn` | Requisições atendidas, mas com fallback ou degradação (ex.: dependência `skipped`) | Abra issue se o volume aumentar em 5m │ configure alertas no Grafana |
| `error` | Fluxos abortados, exceções capturadas, dependências fora do ar | Gatilho para incidentes; deve ter `code` ou `dependency` |
| `fatal` | Reservado para falhas que derrubam o processo (não usado hoje) | Se necessário, integre com o orchestrator para reiniciar pods |

## Coleta de logs por ambiente

### Desenvolvimento

```bash
npm run dev | jq -c '.'

# filtrar apenas request_error
npm run dev | grep 'request_error'
```

- Use `LOG_PRETTY=true npm run dev` quando precisar de saída legível (utilize apenas localmente para não quebrar ingestão).
- Combine com `curl -H "X-Request-ID: debug-123"` para testar correlação.

### Homologação/Produção

1. O contêiner escreve logs JSON em `stdout`/`stderr`.
2. O runtime (Docker, Kubernetes) envia para o agente (Fluent Bit, Vector ou Promtail).
3. Os agentes transmitem para o Loki / Elasticsearch definido em `reports/phase4/alerts.yaml`.

Comandos úteis:

```bash
docker logs backbet-api -f | jq -c 'select(.event == "request_error")'

# Kubernetes
kubectl logs deploy/backbet-api -n backbet --since=30m
```

## Integração com métricas e tracing

- Os mesmos `requestId` e `userId` aparecem nos gauges `backbet_http_in_flight` (labels) e nos spans OTEL, permitindo pivotar entre painéis sem perder contexto.
- O middleware de erro incrementa `backbet_http_errors_total` e emite `request_error`, garantindo que logs e métricas tenham contagens equivalentes.
- Traces incluem atributos `log.level` e `log.event` quando o `DiagConsoleLogger` está em modo `debug` (`OTEL_DIAGNOSTIC_LOG_LEVEL=debug`).

## Boas práticas para novos logs

1. Prefira objetos rasos (no máximo dois níveis) para simplificar queries no Loki.
2. Redija `message` ou `event` em inglês curto e estável (`snake_case`).
3. Não logue dados sensíveis (tokens, segredos, números completos de documentos). Mascarar é obrigatório (`****7890`).
4. Inclua `elapsedMs` ou `latencyMs` sempre que medir uma chamada externa.
5. Evite `console.log` fora do formato JSON; use `JSON.stringify` explicitamente.

## Troubleshooting rápido

| Sintoma | Comando / ação | Resultado esperado |
| --- | --- | --- |
| Endpoint responde 500 | `kubectl logs ... | grep request_error` + `requestId` | Encontrar `code` e `details` para abrir bug |
| Latência alta | `jq 'select(.event=="request_end" and .durationMs>500)'` | Identificar rotas acima do SLO |
| Dependência instável | `grep readiness_dependency` | Confirmar `dependency="redis"` e latência |
| Request sem requestId | Garantir proxy está passando `X-Request-ID` ou deixar middleware gerar | Sempre existir `requestId` nas linhas subsequentes |

## Checklist de mudanças

- [ ] Adicionou log estrutural ao criar fluxo crítico? (depósitos, saques, apostas)
- [ ] Reutilizou `requestId`/`userId` via `getRequestContext()`?
- [ ] Sanitizou payloads antes de logar (`password`, `token`)?
- [ ] Documentou novos campos nesta página e no dashboard (`reports/phase4/dashboard.json`)?

## Próximos passos sugeridos

1. Introduzir `LOG_LEVEL` e `LOG_DESTINATION` no `appConfig` para reduzir volume em produção.
2. Enviar logs diretamente para o agente OTLP (`otlp-logs`) quando for habilitado na stack grafana/tempo/loki.
3. Automatizar testes de contrato que validem `requestId` e `Content-Type` nos logs de erro.

**Última atualização:** 23 de novembro de 2025.
